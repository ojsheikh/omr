#!/bin/perl

################################################################################
##
## (c) Copyright IBM Corp. 2000, 2016
##
##  This program and the accompanying materials are made available
##  under the terms of the Eclipse Public License v1.0 and
##  Apache License v2.0 which accompanies this distribution.
##
##      The Eclipse Public License is available at
##      http://www.eclipse.org/legal/epl-v10.html
##
##      The Apache License v2.0 is available at
##      http://www.opensource.org/licenses/apache2.0.php
##
## Contributors:
##    Multiple authors (IBM Corp.) - initial implementation and documentation
################################################################################

# This program takes as input the file PPCOps.ops and creates the files
# PPCOps.hpp, OpBinary.cpp, OpProperties.cpp, PPPCOpNames.hpp
# It can accept the filenames of the 5 files as command line arguments, or will
# use the default filepaths if none are supplied.

use strict;
use warnings;

# construct pathname for input and output files based on JIT source directory
my $j9_exec_dir     = $ENV{TRSRC};
die("TRSRC not set") unless ($j9_exec_dir);
die("\nUsage: perl ftops.pl {INFILE} {OPSFILE} {PROPSFILE} {BINFILE} {NAMEFILE} {OMR_OPSFILE} {OMR_PROPSFILE} {OMR_BINFILE} \n") unless (@ARGV eq 0 || @ARGV eq 8);
my $inFilePath      = ($ARGV[0])? $ARGV[0] : "$j9_exec_dir/omr/compiler/p/codegen/PPCOps.ops";
my $opsFilePath     = ($ARGV[1])? $ARGV[1] : "$j9_exec_dir/omr/compiler/p/codegen/PPCOps.hpp";
my $propsFilePath   = ($ARGV[2])? $ARGV[2] : "$j9_exec_dir/omr/compiler/p/codegen/OpProperties.cpp";
my $binaryFilePath  = ($ARGV[3])? $ARGV[3] : "$j9_exec_dir/omr/compiler/p/codegen/OpBinary.cpp";
my $nameFilePath    = ($ARGV[4])? $ARGV[4] : "$j9_exec_dir/omr/compiler/ras/PPCOpNames.cpp";

#OMR Files.
my $omr_opsFilePath     = ($ARGV[5])? $ARGV[5] : "$j9_exec_dir/omr/compiler/p/codegen/OMRInstOpCodeEnum.hpp";
my $omr_propsFilePath   = ($ARGV[6])? $ARGV[6] : "$j9_exec_dir/omr/compiler/p/codegen/OMR_OpProperties.cpp";
my $omr_binaryFilePath  = ($ARGV[7])? $ARGV[7] : "$j9_exec_dir/omr/compiler/p/codegen/OMR_OpBinary.cpp";

sub writePrefixes
   {
   my $warning = "// DO NOT EDIT THIS FILE!!!\n// This file was created by a tool.  In order to change the information in this \n// file you must edit the file PPCOps.ops and then run the ftops tool.\n\n";

   die("cannot open input file: $inFilePath") unless open(INFILE,"<$inFilePath");
   die("cannot open ops file: $opsFilePath") unless open(OPSFILE,">$opsFilePath");
   die("cannot open properties file: $propsFilePath") unless open(PROPSFILE,">$propsFilePath");
   die("cannot open binary file: $binaryFilePath") unless open(BINARYFILE,">$binaryFilePath");
   die("cannot open name file: $nameFilePath") unless open(NAMEFILE,">$nameFilePath");

   #OMR Files.
   die("cannot open OMR ops file: $omr_opsFilePath") unless open(OMR_OPSFILE,"<$omr_opsFilePath");
   #die("cannot open OMR properties file: $omr_propsFilePath") unless open(OMR_PROPSFILE,">$omr_propsFilePath");
   #die("cannot open OMR binary file: $omr_binaryFilePath") unless open(OMR_BINARYFILE,">$omr_binaryFilePath");

   print OPSFILE "$warning#if !defined(PPCOPS_INCL)\n#define  PPCOPS_INCL\n\ntypedef enum  {\n";
   print PROPSFILE "$warning#include <stdint.h>                     // for uint32_t\n#include \"codegen/InstOpCode.hpp\"       // for InstOpCode, etc\n#include \"p/codegen/PPCOpsDefines.hpp\"  // for PPCOpProp_SyncSideEffectFree, etc\n\nconst uint32_t OMR::Power::InstOpCode::properties[PPCNumOpCodes] =\n{\n";
   print BINARYFILE "$warning#include \"codegen/InstOpCode.hpp\"  // for InstOpCode, etc\n\nconst TR_PPCOpCodeBinaryEntry OMR::Power::InstOpCode::binaryEncodings[PPCNumOpCodes] =\n{\n";
   print NAMEFILE "$warning#ifndef TR_TARGET_POWER\nint ppcOpNames;\n#else\nconst char * ppcOpCodeToNameMap[][2] =\n   {\n";

   #OMR Files
   my @OMR_OPSFILE_LINES = <OMR_OPSFILE>;
   close OMR_OPSFILE;
   die("cannot open OMR ops file: $omr_opsFilePath") unless open(OMR_OPSFILE,">$omr_opsFilePath");
   foreach my $line (@OMR_OPSFILE_LINES)
      {
      if ($line =~ /(^\s+\*)|(^\/\*)|(^\/\/)|(^\n)/)
         {
         #Keep copyright and comments
         print OMR_OPSFILE $line;
         }
      else
         {
         last;
         }
      }
   #print OMR_OPSFILE    "$warning#if !defined(OMR_PPCOPS_INCL)\n#define  OMR_PPCOPS_INCL\n\ntypedef enum  {\n";
   #print OMR_PROPSFILE  "$warning#include \"codegen/OMR_PPCOpCode.hpp\"\n\nconst uint32_t OMR_PPCOpCode::_properties[OMR_PPCOpCode::PPCNumOpCodes] =\n{\n";
   #print OMR_BINARYFILE "$warning#include \"codegen/OMR_PPCOpCode.hpp\"\n\nconst OMR_PPCOpCode::TR_OpCodeBinaryEntry OMR_PPCOpCode::_binaryEncodings[OMR_PPCOpCode::PPCNumOpCodes] =\n{\n";
   }

sub writeAppendices
   {
   print OPSFILE "   PPCOp_label,\t\t\t\t// Destination of a jump\n   PPCLastOp = PPCOp_label,\n   PPCNumOpCodes = PPCLastOp + 1\n} TR_PPCOpCodes;\n#include \"codegen/PPCOps2.hpp\"\n\n#endif\n";
   print BINARYFILE "	0x00000000   // Label\n};\n";
   print PROPSFILE "// Label\n0\n};\n";
   print NAMEFILE "   {\"label\",	 \"label\"}\n   };\n#endif\n";

   #OMR Files.
   print OMR_OPSFILE "   label,\t\t// Destination of a jump\n   PPCLastOp = label,\n   PPCNumOpCodes = PPCLastOp + 1,\n";
   #print OMR_BINARYFILE "   0x00000000   // Label\n};\n";
   #print OMR_PROPSFILE "// Label\n0\n};\n";

   close INFILE;
   close OPSFILE;
   close PROPSFILE;
   close BINARYFILE;
   close NAMEFILE;

   #OMR Files.
   close OMR_OPSFILE;
   #close OMR_BINARYFILE;
   #close OMR_PROPSFILE;
   }

sub readLine
   {
   my $line = shift;
   $line =~ s/\s+$//; # chomp
   return 0 if !$line or $line =~ /^!/; # skip comments and blank lines
   $line =~ s/\/\// \/\//; # seperate properties from comments
   my ($opcode,$opName,$binary,$properties,@commentArr) = split(' ',$line);
   if ($properties =~ /^\/\//)
      {
      $properties = 0;
      unshift(@commentArr,'//');
      }
   my $comment = join(" ",@commentArr);
   return ($opcode,$opName,$binary,$properties,$comment);
   }

sub printLine
   {
   my ($opcode,$opName,$decbin,$properties,$comment) = (shift,shift,shift,shift,shift);
   my $padding = " " x (17-length($opcode));
   my $hexbin  = sprintf '0x%.8x', $decbin; #convert back to hex

   # singleton cases
   $hexbin = "0x34000000" if $opcode =~ /addi._r/;
   $opName = "addic." if $opcode =~ /addi2_r/;
   ($hexbin,$opName) = ("0x70000000","andi") if $opcode =~ /mr_r/;

   $properties = join(" |\nPPCOpProp_",split(",",$properties));
   $properties = "PPCOpProp_$properties" unless ($properties eq 0);

   print OPSFILE "   PPCOp_$opcode,$padding$comment\n";
   print PROPSFILE "// $opcode\n$properties,\n\n";
   print BINARYFILE "   $hexbin,  // $opcode\n";
   print NAMEFILE "   {\"$opcode\",\t \"$opName\"},\n";

   #OMR Files.
   $opcode = uc $opcode if $opcode =~ /^(and|or|xor)$/;
   print OMR_OPSFILE "   $opcode,$padding$comment\n";
   #print OMR_PROPSFILE "// $opcode\n$properties,\n\n";
   #print OMR_BINARYFILE "   $hexbin,  // $opcode\n";
   }

# ------------------------ MAIN ------------------------ #
writePrefixes();

while(<INFILE>)
   {
   my ($opcode,$opName,$binary,$properties,$comment) = readLine($_);
   next if ($opcode eq 0);  # skip comments and blank lines
   printLine($opcode,$opName,hex($binary),$properties,$comment);
   printLine("$opcode\_r","$opName.",hex($binary)+1,$properties,"$comment with record") if ($properties =~ s/HasRecordForm/IsRecordForm/);
   }

writeAppendices();
# -------------------- END OF MAIN --------------------- #
