/*******************************************************************************
 *
 * (c) Copyright IBM Corp. 2000, 2016
 *
 *  This program and the accompanying materials are made available
 *  under the terms of the Eclipse Public License v1.0 and
 *  Apache License v2.0 which accompanies this distribution.
 *
 *      The Eclipse Public License is available at
 *      http://www.eclipse.org/legal/epl-v10.html
 *
 *      The Apache License v2.0 is available at
 *      http://www.opensource.org/licenses/apache2.0.php
 *
 * Contributors:
 *    Multiple authors (IBM Corp.) - initial implementation and documentation
 *******************************************************************************/

// DO NOT EDIT THIS FILE!!!
// This file was created by a tool.  In order to change the information in this
// file you must edit the file PPCOps.ops and then run the ftops tool.

#if !defined(PPCOPS_INCL)
#define  PPCOPS_INCL

typedef enum  {
   PPCOp_bad,              // Illegal Opcode
   PPCOp_add,              // Add
   PPCOp_add_r,            // Add with record
   PPCOp_addc,             // Add carrying
   PPCOp_addc_r,           // Add carrying with record
   PPCOp_addco,            // Add carrying setting overflow
   PPCOp_addco_r,          // Add carrying setting overflow with record
   PPCOp_adde,             // Add extended
   PPCOp_adde_r,           // Add extended with record
   PPCOp_addeo,            // Add extended setting overflow
   PPCOp_addeo_r,          // Add extended setting overflow with record
   PPCOp_addi,             // Add immediate
   PPCOp_addic,            // Add immediate carrying
   PPCOp_addic_r,          // Add immediate carrying with record
   PPCOp_addi2,            // Add imm (carry bit set only if record form)
   PPCOp_addi2_r,          // Add imm (carry bit set only if record form) with record
   PPCOp_addis,            // Add immediate shifted
   PPCOp_addme,            // Add to minus one extended
   PPCOp_addme_r,          // Add to minus one extended with record
   PPCOp_addmeo,           // Add to minus one extended setting overflow
   PPCOp_addmeo_r,         // Add to minus one extended setting overflow with record
   PPCOp_addo,             // Add setting overflow
   PPCOp_addo_r,           // Add setting overflow with record
   PPCOp_addpcis,          //Add PC Immediate Shifted
   PPCOp_addze,            // Add to zero extended
   PPCOp_addze_r,          // Add to zero extended with record
   PPCOp_addzeo,           // Add to zero extended setting overflow
   PPCOp_addzeo_r,         // Add to zero extended setting overflow with record
   PPCOp_and,              // AND
   PPCOp_and_r,            // AND with record
   PPCOp_andc,             // AND with complement
   PPCOp_andc_r,           // AND with complement with record
   PPCOp_addex,            // Add Extended using alternate carry bits
   PPCOp_addex_r,          // Add Extended using alternate carry bits with record
   PPCOp_andi_r,           // AND immediate
   PPCOp_andis_r,          // AND immediate shifted
   PPCOp_b,                // Unconditional branch
   PPCOp_ba,               // Branch to absolute address
   PPCOp_bctr,             // Branch to count register
   PPCOp_bctrl,            // Branch to count register and link
   PPCOp_bdnz,             // Branch if CTR!=0 after decrementing it
   PPCOp_bdz,              // Branch if CTR==0 after decrementing it
   PPCOp_beq,              // Branch if equal
   PPCOp_beql,             // Branch and link if equal
   PPCOp_bfctr,            // Branch false to count register
   PPCOp_bge,              // Branch if greater than or equal
   PPCOp_bgel,             // Branch and link if greater than or equal
   PPCOp_bgt,              // Branch if greater than
   PPCOp_bgtl,             // Branch and link if greater than
   PPCOp_bl,               // Branch and link
   PPCOp_ble,              // Branch if less than or equal
   PPCOp_blel,             // Branch and link if less than or equal
   PPCOp_blt,              // Branch if less than
   PPCOp_bltl,             // Branch and link if less than
   PPCOp_bla,              // Branch and link to absolute address
   PPCOp_blr,              // Branch to link register
   PPCOp_blrl,             // Branch to link register and link
   PPCOp_bne,              // Branch if not equal
   PPCOp_bnel,             // Branch and link if not equal
   PPCOp_bnun,             // Branch if not unordered
   PPCOp_btctr,            // Branch true to count register
   PPCOp_bun,              // Branch if unordered
   PPCOp_beqlr,            // Branch to link register if equal
   PPCOp_bgelr,            // Branch to link register if greater than or equal
   PPCOp_bgtlr,            // Branch to link register if greater than
   PPCOp_blelr,            // Branch to link register if less than or equal
   PPCOp_bltlr,            // Branch to link register if less than
   PPCOp_bnelr,            // Branch to link register if not equal
   PPCOp_cmp4,             // Compare word algebraic
   PPCOp_cmp8,             // Compare dword algebraic
   PPCOp_cmpi4,            // Compare word immediate algebraic
   PPCOp_cmpi8,            // Compare dword immediate algebraic
   PPCOp_cmpl4,            // Compare word logical
   PPCOp_cmpl8,            // Compare dword logical
   PPCOp_cmpli4,           // Compare word immediate logical
   PPCOp_cmpli8,           // Compare dword immediate logical
   PPCOp_cmprb,            // Compare Ranged Byte
   PPCOp_cmpeqb,           // Compare Equal Byte
   PPCOp_cntlzd,           // Count leading zeros dword
   PPCOp_cntlzd_r,         // Count leading zeros dword with record
   PPCOp_cntlzw,           // Count leading zeros word
   PPCOp_cntlzw_r,         // Count leading zeros word with record
   PPCOp_crand,            // Condition register AND
   PPCOp_crandc,           // Condition register AND with complement
   PPCOp_creqv,            // Condition register equivalent
   PPCOp_crnand,           // Condition register NAND
   PPCOp_crnor,            // Condition register NOR
   PPCOp_cror,             // Condition register OR
   PPCOp_crorc,            // Condition register OR with complement
   PPCOp_crxor,            // Condition register XOR
   PPCOp_dadd,             // Add (DFP64)
   PPCOp_dadd_r,           // Add (DFP64) with record
   PPCOp_darn,             // Deliver a random number
   PPCOp_dcbt,             // Data cache block touch
   PPCOp_dcbtst,           // Data cache block touch for store
   PPCOp_dcbtstt,          // Data cache block touch for store - transient
   PPCOp_dcbtt,            // Data cache block touch - transient
   PPCOp_dcbz,             // Data cache block zero
   PPCOp_dcffix,           // Convert From Fixed (DFP64)
   PPCOp_dcffix_r,         // Convert From Fixed (DFP64) with record
   PPCOp_dcffixq,          // Convert From Fixed (DFP128)
   PPCOp_dcffixq_r,        // Convert From Fixed (DFP128) with record
   PPCOp_dcmpu,            // Unordered Compare (DFP64)
   PPCOp_dctfix,           // Convert to Fixed (DFP64)
   PPCOp_dctfix_r,         // Convert to Fixed (DFP64) with record
   PPCOp_ddedpd,           // Decode DPD to BCD (DFP64)
   PPCOp_ddedpd_r,         // Decode DPD to BCD (DFP64) with record
   PPCOp_ddiv,             // Divide (DFP64)
   PPCOp_ddiv_r,           // Divide (DFP64) with record
   PPCOp_denbcdu,          // Encode Unsigned BCD to DFP (DFP64)
   PPCOp_denbcdu_r,        // Encode Unsigned BCD to DFP (DFP64) with record
   PPCOp_divd,             // Divide dword
   PPCOp_divd_r,           // Divide dword with record
   PPCOp_diex,             // Insert Biased Exponent (DFP64)
   PPCOp_diex_r,           // Insert Biased Exponent (DFP64) with record
   PPCOp_divdo,            // Divide dword setting overflow
   PPCOp_divdo_r,          // Divide dword setting overflow with record
   PPCOp_divdu,            // Divide dword unsigned
   PPCOp_divdu_r,          // Divide dword unsigned with record
   PPCOp_divduo,           // Divide dword unsigned setting overflow
   PPCOp_divduo_r,         // Divide dword unsigned setting overflow with record
   PPCOp_divw,             // Divide word
   PPCOp_divw_r,           // Divide word with record
   PPCOp_divwo,            // Divide word setting overflow
   PPCOp_divwo_r,          // Divide word setting overflow with record
   PPCOp_divwu,            // Divide word unsigned
   PPCOp_divwu_r,          // Divide word unsigned with record
   PPCOp_divwuo,           // Divide word unsigned setting overflow
   PPCOp_divwuo_r,         // Divide word unsigned setting overflow with record
   PPCOp_dmul,             // Multiply (DFP64)
   PPCOp_dmul_r,           // Multiply (DFP64) with record
   PPCOp_dqua,             // Quantize (DFP64)
   PPCOp_dqua_r,           // Quantize (DFP64) with record
   PPCOp_drrnd,            // Reround (DFP64)
   PPCOp_drrnd_r,          // Reround (DFP64) with record
   PPCOp_drdpq,            // Round To DFP64 (DFP128)
   PPCOp_drdpq_r,          // Round To DFP64 (DFP128) with record
   PPCOp_dsub,             // Subtract (DFP64)
   PPCOp_dsub_r,           // Subtract (DFP64) with record
   PPCOp_dtstdc,           // Test Data Class (DFP64)
   PPCOp_dtstdg,           // Test Data Group (DFP64)
   PPCOp_dxex,             // Extract Biased Exponent (DFP64)
   PPCOp_dxex_r,           // Extract Biased Exponent (DFP64) with record
   PPCOp_eieio,            // Enforce in order execution of I/O
   PPCOp_eqv,              // Equivalent
   PPCOp_eqv_r,            // Equivalent with record
   PPCOp_extsb,            // Extend sign byte
   PPCOp_extsb_r,          // Extend sign byte with record
   PPCOp_extsh,            // Extend sign half word
   PPCOp_extsh_r,          // Extend sign half word with record
   PPCOp_extsw,            // Extend sign word
   PPCOp_extsw_r,          // Extend sign word with record
   PPCOp_extswsli,         // Extend Sign Word & Shift Left Immediate
   PPCOp_extswsli_r,       // Extend Sign Word & Shift Left Immediate with record
   PPCOp_fabs,             // Floating absolute value
   PPCOp_fadd,             // Floating add
   PPCOp_fadds,            // Floating add single
   PPCOp_fcfid,            // Floating convert from integer dword
   PPCOp_fcfidu,           // Floating convert from integer dword unsigned
   PPCOp_fcfids,           // Floating convert from integer dword single
   PPCOp_fcfidus,          // Floating convert from integer dword unsigned single
   PPCOp_fcmpo,            // Floating compare ordered
   PPCOp_fcmpu,            // Floating compare unordered
   PPCOp_fcpsgn,           // Floating copy sign
   PPCOp_fctid,            // Floating convert to integer dword
   PPCOp_fctidz,           // Floating convert to integer dword round toward zero
   PPCOp_fctiw,            // Floating convert to integer word
   PPCOp_fctiwz,           // Floating convert to integer word round toward zero
   PPCOp_fdiv,             // Floating divide double
   PPCOp_fdivs,            // Floating divide single
   PPCOp_fmadd,            // Floating multiply add double
   PPCOp_fmadds,           // Floating multiply add single
   PPCOp_fmr,              // Floating move register
   PPCOp_fmsub,            // Floating multiply subtract double
   PPCOp_fmsubs,           // Floating multiply subtract single
   PPCOp_fmul,             // Floating multiply double
   PPCOp_fmuls,            // Floating multiply single
   PPCOp_fnabs,            // Floating negative absolute value
   PPCOp_fneg,             // Floating negate
   PPCOp_fnmadd,           // Floating negative multiply add double
   PPCOp_fnmadds,          // Floating negative multiply add single
   PPCOp_fnmsub,           // Floating negative multiply subtract double
   PPCOp_fnmsubs,          // Floating negative multiply subtract single
   PPCOp_fres,             // Floating reciprocal estimate single
   PPCOp_frim,             // Floating round to minus (floor) double
   PPCOp_frin,             // Floating round to nearest double
   PPCOp_frip,             // Floating round to plus (ceil) double
   PPCOp_frsp,             // Floating round to single
   PPCOp_frsqrte,          // Floating reciprocal square root estimate
   PPCOp_fsel,             // Floating select
   PPCOp_fsqrt,            // Floating square root double
   PPCOp_fsqrts,           // Floating square root single
   PPCOp_fsub,             // Floating subtract double
   PPCOp_fsubs,            // Floating subtract single
   PPCOp_isync,            // Instruction synchronize
   PPCOp_lbz,              // Load byte and zero extend
   PPCOp_lbzu,             // Load byte and zero extend with update
   PPCOp_lbzux,            // Load byte and zero extend with update indexed
   PPCOp_lbzx,             // Load byte and zero extend indexed
   PPCOp_ld,               // Load dword
   PPCOp_ldarx,            // Load dword and reserve indexed
   PPCOp_ldmx,             // Load dword monitored indexed
   PPCOp_lwzmx,            // Load word and zero monitored indexed
   PPCOp_ldu,              // Load dword with update
   PPCOp_ldux,             // Load dword with update indexed
   PPCOp_ldx,              // Load dword indexed
   PPCOp_lfd,              // Load floating point double
   PPCOp_lfdp,             // Load floating point double pair
   PPCOp_lfdu,             // Load floating point double with update
   PPCOp_lfdux,            // Load floating point double with update indexed
   PPCOp_lfdx,             // Load floating point double indexed
   PPCOp_lfdpx,            // Load floating point double pair indexed
   PPCOp_lfiwax,           // Load floating point as integer word algebraic
   PPCOp_lfiwzx,           // Load floating point as integer word and zero indexed
   PPCOp_lfs,              // Load floating short
   PPCOp_lfsu,             // Load floating short with update
   PPCOp_lfsux,            // Load floating short with update indexed
   PPCOp_lfsx,             // Load floating short indexed
   PPCOp_lha,              // Load half word algebraic
   PPCOp_lhau,             // Load half word algebraic
   PPCOp_lhaux,            // Load half word algebraic
   PPCOp_lhax,             // Load half word algebraic
   PPCOp_lhbrx,            // Load half word byte reversed indexed
   PPCOp_lhz,              // Load half word and zero extend
   PPCOp_lhzu,             // Load half word and zero extend with update
   PPCOp_lhzux,            // Load half word and zero extend with update indexed
   PPCOp_lhzx,             // Load half word and zero extend indexed
   PPCOp_li,               // Load immediate
   PPCOp_lis,              // Load immediate shifted
   PPCOp_lmw,              // Load multiple word
   PPCOp_lswi,             // Load string word immediate
   PPCOp_lswx,             // Load string word indexed
   PPCOp_lwa,              // Load word algebraic
   PPCOp_lwarx,            // Load word and reserve indexed
   PPCOp_lwaux,            // Load word algebraic with update indexed
   PPCOp_lwax,             // Load word algebraic indexed
   PPCOp_lwbrx,            // Load word byte reverse indexed
   PPCOp_ldbrx,            // Load doubleword byte reverse indexed
   PPCOp_lwsync,           // Lightweight Synchronize
   PPCOp_lwz,              // Load word and zero extend
   PPCOp_lwzu,             // Load word and zero extend with update
   PPCOp_lwzux,            // Load word and zero with update indexed
   PPCOp_lwzx,             // Load word and zero extend indexed
   PPCOp_maddld,           // Multiply-Add Low Dword
   PPCOp_mcrf,             // Move condition register field
   PPCOp_mcrfs,            // Move to condition register field from FPSCR
   PPCOp_mcrxr,            // Move to condition register field from XER
   PPCOp_mfcr,             // Move from condition register to gpr
   PPCOp_mfocrf,           // Move from one condition register field to gpr (XFX-form)
   PPCOp_mfctr,            // Move from count register to gpr
   PPCOp_mffgpr,           // Move Floating-Point From GPR
   PPCOp_mffs,             // Move from FPSCR to gpr
   PPCOp_mflr,             // Move from link register to gpr
   PPCOp_mfmsr,            // Move from machine state register
   PPCOp_mfspr,            // Move from special purpose register to gpr
   PPCOp_mftexasr,         // Move from transaction exception and summary register to gpr
   PPCOp_mftexasru,        // Move from upper 32 bits of transaction exception and summary register to gpr
   PPCOp_mftgpr,           // Move Floating-Point To GPR
   PPCOp_modud,            // Modulo unsigned DWord
   PPCOp_modsd,            // Modulo signed DWord
   PPCOp_moduw,            // Modulo unsigned word
   PPCOp_modsw,            // Modulo signed word
   PPCOp_mr,               // Register copy
   PPCOp_mtcrf,            // Move to condition register fields from gpr
   PPCOp_mtctr,            // Move to count register from gpr
   PPCOp_mtfsb0,           // Move to FPSCR bit 0
   PPCOp_mtfsb1,           // Move to FPSCR bit 1
   PPCOp_mtfsfl,           // Move to FPSCR fields L=1
   PPCOp_mtfsfl_r,         // Move to FPSCR fields L=1 with record
   PPCOp_mtfsf,            // Move to FPSCR fields L=0/W=0
   PPCOp_mtfsf_r,          // Move to FPSCR fields L=0/W=0 with record
   PPCOp_mtfsfw,           // Move to FPSCR fields L=0/W=1
   PPCOp_mtfsfw_r,         // Move to FPSCR fields L=0/W=1 with record
   PPCOp_mtfsfi,           // Move to FPSCR field immediate
   PPCOp_mtfsfi_r,         // Move to FPSCR field immediate with record
   PPCOp_mtlr,             // Move to link register from gpr
   PPCOp_mtmsr,            // Move to machine state register
   PPCOp_mtspr,            // Move to special purpose register
   PPCOp_mfvsrd,           // Move From VSR Doubleword
   PPCOp_mfvsrwz,          // Move From VSR Word and Zero
   PPCOp_mtvsrd,           // Move To VSR Doubleword
   PPCOp_mtvsrwz,          // Move To VSR Word and Zero
   PPCOp_mtvsrwa,          // Move To VSR Word and Zero Sign-Extend
   PPCOp_mulhd,            // Multiply high dword
   PPCOp_mulhd_r,          // Multiply high dword with record
   PPCOp_mulhdu,           // Multiply high dword unsigned
   PPCOp_mulhdu_r,         // Multiply high dword unsigned with record
   PPCOp_mulhw,            // Multiply high word
   PPCOp_mulhw_r,          // Multiply high word with record
   PPCOp_mulhwu,           // Multiply high word unsigned
   PPCOp_mulhwu_r,         // Multiply high word unsigned with record
   PPCOp_mulld,            // Multiply low dword
   PPCOp_mulld_r,          // Multiply low dword with record
   PPCOp_mulldo,           // Multiply low dword setting overflow
   PPCOp_mulldo_r,         // Multiply low dword setting overflow with record
   PPCOp_mulli,            // Multiply low immediate
   PPCOp_mullw,            // Multiply low word
   PPCOp_mullw_r,          // Multiply low word with record
   PPCOp_mullwo,           // Multiply low word setting overflow
   PPCOp_mullwo_r,         // Multiply low word setting overflow with record
   PPCOp_nand,             // NAND
   PPCOp_nand_r,           // NAND with record
   PPCOp_neg,              // Negate
   PPCOp_neg_r,            // Negate with record
   PPCOp_nego,             // Negate setting overflow
   PPCOp_nego_r,           // Negate setting overflow with record
   PPCOp_nor,              // NOR
   PPCOp_nor_r,            // NOR with record
   PPCOp_or,               // OR
   PPCOp_or_r,             // OR with record
   PPCOp_orc,              // OR with complement
   PPCOp_orc_r,            // OR with complement with record
   PPCOp_ori,              // OR immediate
   PPCOp_oris,             // OR immediate shifted
   PPCOp_popcntd,          // Population count dword
   PPCOp_popcntw,          // Population count word
   PPCOp_rfi,              // Return from interrupt
   PPCOp_rldcl,            // Rotate left dword then clear left
   PPCOp_rldcl_r,          // Rotate left dword then clear left with record
   PPCOp_rldcr,            // Rotate left dword then clear right
   PPCOp_rldcr_r,          // Rotate left dword then clear right with record
   PPCOp_rldic,            // Rotate left dword immediate then clear
   PPCOp_rldic_r,          // Rotate left dword immediate then clear with record
   PPCOp_rldicl,           // Rotate left dword immediate then clear left
   PPCOp_rldicl_r,         // Rotate left dword immediate then clear left with record
   PPCOp_rldicr,           // Rotate left dword immediate then clear right
   PPCOp_rldicr_r,         // Rotate left dword immediate then clear right with record
   PPCOp_rldimi,           // Rotate left dword immediate then mask insert
   PPCOp_rldimi_r,         // Rotate left dword immediate then mask insert with record
   PPCOp_rlwimi,           // Rotate left word immediate then mask insert
   PPCOp_rlwimi_r,         // Rotate left word immediate then mask insert with record
   PPCOp_rlwinm,           // Rotate left word immediate then AND with mask
   PPCOp_rlwinm_r,         // Rotate left word immediate then AND with mask with record
   PPCOp_rlwnm,            // Rotate left word then AND with mask
   PPCOp_rlwnm_r,          // Rotate left word then AND with mask with record
   PPCOp_setb,             // Set Boolean
   PPCOp_sld,              // Shift left dword
   PPCOp_sld_r,            // Shift left dword with record
   PPCOp_slw,              // Shift left word
   PPCOp_slw_r,            // Shift left word with record
   PPCOp_srad,             // Shift right algebraic dword
   PPCOp_srad_r,           // Shift right algebraic dword with record
   PPCOp_sradi,            // Shift right algebraic dword immediate
   PPCOp_sradi_r,          // Shift right algebraic dword immediate with record
   PPCOp_sraw,             // Shift right algebraic word
   PPCOp_sraw_r,           // Shift right algebraic word with record
   PPCOp_srawi,            // Shift right algebraic word immediate
   PPCOp_srawi_r,          // Shift right algebraic word immediate with record
   PPCOp_srd,              // Shift right dword
   PPCOp_srd_r,            // Shift right dword with record
   PPCOp_srw,              // Shift right word
   PPCOp_srw_r,            // Shift right word with record
   PPCOp_stb,              // Store byte
   PPCOp_stbu,             // Store byte with update
   PPCOp_stbux,            // Store byte with update indexed
   PPCOp_stbx,             // Store byte indexed
   PPCOp_std,              // Store dword
   PPCOp_stdcx_r,          // Store word conditional indexed
   PPCOp_stdu,             // Store dword with update
   PPCOp_stdux,            // Store dword with update indexed
   PPCOp_stdx,             // Store dword indexed
   PPCOp_stfd,             // Store float double
   PPCOp_stfdp,            // Store float double pair
   PPCOp_stfdu,            // Store float double with update
   PPCOp_stfdux,           // Store float double with update indexed
   PPCOp_stfdx,            // Store float double indexed
   PPCOp_stfdpx,           // Store float double pair indexed
   PPCOp_stfiwx,           // Store float as integer word indexed
   PPCOp_stfs,             // Store float single
   PPCOp_stfsu,            // Store float single with update
   PPCOp_stfsux,           // Store float single with update indexed
   PPCOp_stfsx,            // Store float single indexed
   PPCOp_sth,              // Store half word
   PPCOp_sthbrx,           // Store half word byte reversed indexed
   PPCOp_sthu,             // Store half word with update
   PPCOp_sthux,            // Store half word with update indexed
   PPCOp_sthx,             // Store half word indexed
   PPCOp_stmw,             // Store multiple word
   PPCOp_stswi,            // Store string word immediate
   PPCOp_stswx,            // Store string word indexed
   PPCOp_stw,              // Store word
   PPCOp_stwbrx,           // Store word byte reverse indexed
   PPCOp_stdbrx,           // Store doubleword byte reverse indexed
   PPCOp_stwcx_r,          // Store word conditional indexed
   PPCOp_stwu,             // Store word with update
   PPCOp_stwux,            // Store word with update indexed
   PPCOp_stwx,             // Store word indexed
   PPCOp_subf,             // Subtract from
   PPCOp_subf_r,           // Subtract from with record
   PPCOp_subfc,            // Subtract from carrying
   PPCOp_subfc_r,          // Subtract from carrying with record
   PPCOp_subfco,           // Subtract from carrying setting overflow
   PPCOp_subfco_r,         // Subtract from carrying setting overflow with record
   PPCOp_subfe,            // Subtract from extended
   PPCOp_subfe_r,          // Subtract from extended with record
   PPCOp_subfeo,           // Subtract from extended setting overflow
   PPCOp_subfeo_r,         // Subtract from extended setting overflow with record
   PPCOp_subfic,           // Subtract from immediate carrying
   PPCOp_subfme,           // Subtract from minus one extended
   PPCOp_subfme_r,         // Subtract from minus one extended with record
   PPCOp_subfmeo,          // Subtract from minus one extended setting overflow
   PPCOp_subfmeo_r,        // Subtract from minus one extended setting overflow with record
   PPCOp_subfze,           // Subtract from zero extended
   PPCOp_subfze_r,         // Subtract from zero extended with record
   PPCOp_subfzeo,          // Subtract from zero extended setting overflow
   PPCOp_subfzeo_r,        // Subtract from zero extended setting overflow with record
   PPCOp_sync,             // Synchronize
   PPCOp_tabort_r,         // Transactional Memory abort
   PPCOp_tabortdeq_r,      // Transactional Memory abort dword if equal
   PPCOp_tabortdeqi_r,     // Transactional Memory abort dword if equal to immediate value
   PPCOp_tabortdge_r,      // Transactional Memory abort dword if greater than or equal to
   PPCOp_tabortdgei_r,     // Transactional Memory abort dword if greater than or equal to immediate
   PPCOp_tabortdgt_r,      // Transactional Memory abort dword if greater than
   PPCOp_tabortdgti_r,     // Transactional Memory abort dword if greater than immediate
   PPCOp_tabortdle_r,      // Transactional Memory abort dword if less than or equal to
   PPCOp_tabortdlei_r,     // Transactional Memory abort dword if less than or equal to immediate
   PPCOp_tabortdlge_r,     // Transactional Memory abort dword if logically greater than or equal to
   PPCOp_tabortdlgei_r,    // Transactional Memory abort dword if logically greater than or equal to immediate
   PPCOp_tabortdlgt_r,     // Transactional Memory abort dword if logically greater than
   PPCOp_tabortdlgti_r,    // Transactional Memory abort dword if logically greater than immediate
   PPCOp_tabortdlle_r,     // Transactional Memory abort dword if logically less than or equal to
   PPCOp_tabortdllei_r,    // Transactional Memory abort dword if logically less than or equal to immediate
   PPCOp_tabortdllt_r,     // Transactional Memory abort dword if logically less than
   PPCOp_tabortdllti_r,    // Transactional Memory abort dword if logically less than immediate
   PPCOp_tabortdlt_r,      // Transactional Memory abort dword if less than
   PPCOp_tabortdlti_r,     // Transactional Memory abort dword if less than immediate
   PPCOp_tabortdneq_r,     // Transactional Memory abort dword if not equal to
   PPCOp_tabortdneqi_r,    // Transactional Memory abort dword if not equal to immediate
   PPCOp_tabortweq_r,      // Transactional Memory abort if equal
   PPCOp_tabortweqi_r,     // Transactional Memory abort if equal to immediate value
   PPCOp_tabortwge_r,      // Transactional Memory abort if greater than or equal to
   PPCOp_tabortwgei_r,     // Transactional Memory abort if greater than or equal to immediate
   PPCOp_tabortwgt_r,      // Transactional Memory abort if greater than
   PPCOp_tabortwgti_r,     // Transactional Memory abort if greater than immediate
   PPCOp_tabortwle_r,      // Transactional Memory abort if less than or equal to
   PPCOp_tabortwlei_r,     // Transactional Memory abort if less than or equal to immediate
   PPCOp_tabortwlge_r,     // Transactional Memory abort if logically greater than or equal to
   PPCOp_tabortwlgei_r,    // Transactional Memory abort if logically greater than or equal to immediate
   PPCOp_tabortwlgt_r,     // Transactional Memory abort if logically greater than
   PPCOp_tabortwlgti_r,    // Transactional Memory abort if logically greater than immediate
   PPCOp_tabortwlle_r,     // Transactional Memory abort if logically less than or equal to
   PPCOp_tabortwllei_r,    // Transactional Memory abort if logically less than or equal to immediate
   PPCOp_tabortwllt_r,     // Transactional Memory abort if logically less than
   PPCOp_tabortwllti_r,    // Transactional Memory abort if logically less than immediate
   PPCOp_tabortwlt_r,      // Transactional Memory abort if less than
   PPCOp_tabortwlti_r,     // Transactional Memory abort if less than immediate
   PPCOp_tabortwneq_r,     // Transactional Memory abort if not equal to
   PPCOp_tabortwneqi_r,    // Transactional Memory abort if not equal to immediate
   PPCOp_tbegin_r,         // Begin transaction
   PPCOp_tbeginro_r,       // Begin roll-back only transaction
   PPCOp_tend_r,           // End transaction (supports nesting)
   PPCOp_tendall_r,        // End transaction
   PPCOp_tdeq,             // Trap dword if equal
   PPCOp_tdeqi,            // Trap dword if equal to immediate value
   PPCOp_tdge,             // Trap dword if greater than or equal to
   PPCOp_tdgei,            // Trap dword if greater than or equal to immediate value
   PPCOp_tdgt,             // Trap dword if greater than
   PPCOp_tdgti,            // Trap dword if greater than immediate value
   PPCOp_tdle,             // Trap dword if less than or equal to
   PPCOp_tdlei,            // Trap dword if less than or equal to immediate value
   PPCOp_tdlge,            // Trap dword if logically greater than or equal to
   PPCOp_tdlgei,           // Trap dword if logically greater than or equal to immediate value
   PPCOp_tdlgt,            // Trap dword if logically greater than
   PPCOp_tdlgti,           // Trap dword if logically greater than immediate value
   PPCOp_tdlle,            // Trap dword if logically less than or equal to
   PPCOp_tdllei,           // Trap dword if logically less than or equal to immediate value
   PPCOp_tdllt,            // Trap dword if logically less than
   PPCOp_tdllti,           // Trap dword if logically less than immediate value
   PPCOp_tdlt,             // Trap dword if less than
   PPCOp_tdlti,            // Trap dword if less than immediate value
   PPCOp_tdneq,            // Trap dword if not equal
   PPCOp_tdneqi,           // Trap dword if not equal to immediate value
   PPCOp_trap,             // Unconditional trap
   PPCOp_tweq,             // Trap word if equal
   PPCOp_tweqi,            // Trap word if equal to immediate value
   PPCOp_twge,             // Trap word if greater than or equal to
   PPCOp_twgei,            // Trap word if greater than or equal to immediate value
   PPCOp_twgt,             // Trap word if greater than
   PPCOp_twgti,            // Trap word if greater than immediate value
   PPCOp_twle,             // Trap word if less than or equal to
   PPCOp_twlei,            // Trap word if less than or equal to immediate value
   PPCOp_twlge,            // Trap word if logically greater than or equal to
   PPCOp_twlgei,           // Trap word if logically greater than or equal to immediate value
   PPCOp_twlgt,            // Trap word if logically greater than
   PPCOp_twlgti,           // Trap word if logically greater than immediate value
   PPCOp_twlle,            // Trap word if logically less than or equal to
   PPCOp_twllei,           // Trap word if logically less than or equal to immediate value
   PPCOp_twllt,            // Trap word if logically less than
   PPCOp_twllti,           // Trap word if logically less than immediate value
   PPCOp_twlt,             // Trap word if less than
   PPCOp_twlti,            // Trap word if less than immediate value
   PPCOp_twneq,            // Trap word if not equal
   PPCOp_twneqi,           // Trap word if not equal to immediate value
   PPCOp_xor,              // XOR
   PPCOp_xor_r,            // XOR with record
   PPCOp_xori,             // XOR immediate
   PPCOp_xoris,            // XOR immediate shifted
   PPCOp_nop,              // NoOp (ori)
   PPCOp_genop,            // Group Ending NoOp (ori)
   PPCOp_fence,            // Fence
   PPCOp_shdfence,         // Scheduling Fence
   PPCOp_ret,              // Return
   PPCOp_wrtbar,           // Write barrier directive
   PPCOp_proc,             // Entry to the method
   PPCOp_dd,               // define word
   PPCOp_assocreg,         // Associate real registers with Virtual registers.
   PPCOp_vgdnop,           // Virtual Guard NOP instruction
   PPCOp_depend,           // Instruction to hang dependency on
   PPCOp_probenop,         // Probe NOP (for RI)
   PPCOp_iflong,           // compare and branch long
   PPCOp_setblong,         // compare long and set boolean
   PPCOp_setbool,          // compare and set boolean (int or simple float)
   PPCOp_setbflt,          // compare float and set boolean (complex float)
   PPCOp_lcmp,             // compare long and set result -1,0,1
   PPCOp_flcmpl,           // compare float and set result -1(less,unordered),0(equal),1(greater)
   PPCOp_flcmpg,           // compare float and set result -1(less),0(equal),1(greater,unordered)
   PPCOp_idiv,             // integer divide
   PPCOp_ldiv,             // long divide for 64 bit target
   PPCOp_irem,             // integer remainder
   PPCOp_lrem,             // long remainder for 64 bit target
   PPCOp_cdnan,            // canonise double NaN to 0x7ff80..0 (in gprs)
   PPCOp_cfnan,            // canonise float NaN to 0x7fc00..0 (in gprs)
   PPCOp_d2i,              // converts from double to integer
   PPCOp_d2l,              // converts from double to long
   PPCOp_ifx,              // compare and branch complex
   PPCOp_setbx,            // compare complex and set boolean
   PPCOp_iternary,         // ternary evaluator
   PPCOp_lvsl,             // Load vector for shift left
   PPCOp_lvsr,             // Load vector for shift right
   PPCOp_lvx,              // Load vector indexed
   PPCOp_lvebx,            // Load vector element byte indexed
   PPCOp_lvehx,            // Load vector element halfword indexed
   PPCOp_lvewx,            // Load vector element word indexed
   PPCOp_stvx,             // store vector indexed
   PPCOp_stvebx,           // store vector element byte indexed
   PPCOp_stvehx,           // store vector element halfword indexed
   PPCOp_stvewx,           // store vector element word indexed
   PPCOp_vand,             // vector logical and
   PPCOp_vandc,            // vector logical and with complement
   PPCOp_vor,              // vector or
   PPCOp_vxor,             // vector xor
   PPCOp_vnor,             // vector nor
   PPCOp_vperm,            // vector permute
   PPCOp_vsel,             // vector conditional select
   PPCOp_vsumsws,          // vector sum across signed word saturate
   PPCOp_vsum2sws,         // vector sum across partial signed word saturate
   PPCOp_vsum4sbs,         // vector sum across partial signed byte saturate
   PPCOp_vsum4shs,         // vector sum across partial signed halfword saturate
   PPCOp_vsum4ubs,         // vector sum across partial unsigned byte saturate
   PPCOp_vspltb,           // vector splat byte
   PPCOp_vsplth,           // vector splat halfword
   PPCOp_vspltw,           // vector splat word
   PPCOp_vspltisb,         // vector splat immediate signed byte
   PPCOp_vspltish,         // vector splat immediate signed halfword
   PPCOp_vspltisw,         // vector splat immediate signed word
   PPCOp_vsl,              // vector shift left
   PPCOp_vslb,             // vector shift left byte
   PPCOp_vsldoi,           // vector shift left double by octet immediate
   PPCOp_vslh,             // vector shift left halfword
   PPCOp_vslo,             // vector shift left by octet
   PPCOp_vslw,             // vector shift left word
   PPCOp_vsr,              // vector shift right
   PPCOp_vsrab,            // vector shift right algebraic byte
   PPCOp_vsrah,            // vector shift right algebraic halfword
   PPCOp_vsraw,            // vector shift right algebraic word
   PPCOp_vsrb,             // vector shift right byte
   PPCOp_vsrh,             // vector shift right halfword
   PPCOp_vsro,             // vector shift right by octet
   PPCOp_vsrw,             // vector shift right word
   PPCOp_vrlb,             // vector rotate left byte
   PPCOp_vrlh,             // vector rotate left halfword
   PPCOp_vrlw,             // vector rotate left word
   PPCOp_vaddsbs,          // vector add signed byte saturate
   PPCOp_vaddshs,          // vector add signed halfword saturate
   PPCOp_vaddsws,          // vector add signed word saturate
   PPCOp_vaddubm,          // vector add unsigned byte modulo
   PPCOp_vaddubs,          // vector add unsigned byte saturate
   PPCOp_vadduhm,          // vector add unsigned halfword modulo
   PPCOp_vadduhs,          // vector add unsigned halfword saturate
   PPCOp_vadduwm,          // vector add unsigned word modulo
   PPCOp_vadduws,          // vector add unsigned word saturate
   PPCOp_vsubsbs,          // vector subtract signed byte saturate
   PPCOp_vsubshs,          // vector subtract signed halfword saturate
   PPCOp_vsubsws,          // vector subtract signed word saturate
   PPCOp_vsububm,          // vector subtract unsigned byte modulo
   PPCOp_vsububs,          // vector subtract unsigned byte saturate
   PPCOp_vsubuhm,          // vector subtract unsigned halfword modulo
   PPCOp_vsubuhs,          // vector subtract unsigned halfword saturate
   PPCOp_vsubuwm,          // vector subtract unsigned word modulo
   PPCOp_vsubuws,          // vector subtract unsigned word saturate
   PPCOp_vmulesh,          // vector multiply even signed halfword
   PPCOp_vmulosh,          // vector multiply odd signed halfword
   PPCOp_vmulouh,          // vector multiply odd unsigned halfword
   PPCOp_vmuluwm,          // vector multiply unsigned word modulo
   PPCOp_vminsb,           // vector minimum signed byte
   PPCOp_vminsh,           // vector minimum signed halfword
   PPCOp_vminsw,           // vector minimum signed word
   PPCOp_vminub,           // vector minimum unsigned byte
   PPCOp_vminuh,           // vector minimum unsigned halfword
   PPCOp_vminuw,           // vector minimum unsigned word
   PPCOp_vmaxsb,           // vector maximum signed byte
   PPCOp_vmaxsh,           // vector maximum signed halfword
   PPCOp_vmaxsw,           // vector maximum signed word
   PPCOp_vmaxub,           // vector maximum unsigned byte
   PPCOp_vmaxuh,           // vector maximum unsigned halfword
   PPCOp_vmaxuw,           // vector maximum unsigned word
   PPCOp_vmsumuhm,         // vector multiply-sum unsigned halfword word modulo
   PPCOp_vcmpequb,         // vector compare equal unsigned byte
   PPCOp_vcmpeubr,         // vector compare equal unsigned byte with record
   PPCOp_vcmpequh,         // vector compare equal unsigned halfword
   PPCOp_vcmpeuhr,         // vector compare equal unsigned halfword with record
   PPCOp_vcmpequw,         // vector compare equal unsigned word
   PPCOp_vcmpeuwr,         // vector compare equal unsigned word with record
   PPCOp_vcmpgtsb,         // vector compare greater than signed byte
   PPCOp_vcmpgsbr,         // vector compare greater than signed byte with record
   PPCOp_vcmpgtsh,         // vector compare greater than signed halfword
   PPCOp_vcmpgshr,         // vector compare greater than signed halfword with record
   PPCOp_vcmpgtsw,         // vector compare greater than signed word
   PPCOp_vcmpgswr,         // vector compare greater than signed word with record
   PPCOp_vcmpgtub,         // vector compare greater than unsigned byte
   PPCOp_vcmpgubr,         // vector compare greater than unsigned byte with record
   PPCOp_vcmpgtuh,         // vector compare greater than unsigned halfword
   PPCOp_vcmpguhr,         // vector compare greater than unsigned halfword with record
   PPCOp_vcmpgtuw,         // vector compare greater than unsigned word
   PPCOp_vcmpguwr,         // vector compare greater than unsigned word with record
   PPCOp_vupkhsb,          // vector unpack high signed byte
   PPCOp_vupkhsh,          // vector unpack high signed halfword
   PPCOp_vupklsb,          // vector unpack low signed byte
   PPCOp_vupklsh,          // vector unpack low signed halfword
   PPCOp_vpkuhum,          // vector pack unsigned half word unsigned modulo
   PPCOp_vpkuwum,          // vector pack unsigned word unsigned modulo
   PPCOp_vmrghb,           // vector merge high byte
   PPCOp_vmrghh,           // vector merge high half word
   PPCOp_vmrghw,           // vector merge high word
   PPCOp_vmrglb,           // vector merge low byte
   PPCOp_vmrglh,           // vector merge low half word
   PPCOp_vmrglw,           // vector merge low word
   PPCOp_lxsdx,            // Load VSX Scalar Doubleword Indexed
   PPCOp_lxsdux,           // Load VSX Scalar Doubleword with Update Indexed
   PPCOp_stxsdx,           // Store VSX Scalar Doubleword Indexed
   PPCOp_stxsdux,          // Store VSX Scalar Doubleword with Update Indexed
   PPCOp_lxvd2x,           // Load VSX Vector Doubleword*2 Indexed
   PPCOp_lxvd2ux,          // Load VSX Vector Doubleword*2 with Update Indexed
   PPCOp_lxvdsx,           // Load VSX Vector Doubleword & Splat Indexed
   PPCOp_lxvw4x,           // Load VSX Vector Word*4 Indexed
   PPCOp_lxvw4ux,          // Load VSX Vector Word*4 with Update Indexed
   PPCOp_stxvd2x,          // store VSX Vector Doubleword*2 Indexed
   PPCOp_stxvd2ux,         // store VSX Vector Doubleword*2 with Update Indexed
   PPCOp_stxvw4x,          // store VSX Vector Word*4 Indexed
   PPCOp_stxvw4ux,         // store VSX Vector Word*4 with Update Indexed
   PPCOp_xsabsdp,          // VSX Scalar Absolute Value Double-Precision
   PPCOp_xsadddp,          // VSX Scalar Add Double-Precision
   PPCOp_xscmpodp,         // VSX Scalar Compare Ordered Double-Precision
   PPCOp_xscmpudp,         // VSX Scalar Compare Unordered Double-Precision
   PPCOp_xscpsgndp,        // VSX Scalar Copy Sign Double-Precision , For VSR Copy register
   PPCOp_xscvdpsxds,       // VSX Scalar Convert Double-Precision to Signed Integer Doubleword Saturate
   PPCOp_xscvdpsxws,       // VSX Scalar Convert Double-Precision to Signed Integer Word Saturate
   PPCOp_xsdivdp,          // VSX Scalar Divide Double-Precision
   PPCOp_xsmaddadp,        // VSX Scalar Multiply-Add Type A Double-Precision
   PPCOp_xsmaddmdp,        // VSX Scalar Multiply-Add Type M Double-Precision
   PPCOp_xsmsubadp,        // VSX Scalar Multiply-Subtract Type A Double-Precision
   PPCOp_xsmsubmdp,        // VSX Scalar Multiply-Subtract Type M Double-Precision
   PPCOp_xsmuldp,          // VSX Scalar Multiply Double-Precision
   PPCOp_xsnabsdp,         // VSX Scalar Negative Absolute Value Double-Precision
   PPCOp_xsnegdp,          // VSX Scalar Negate Double-Precision
   PPCOp_xsnmaddadp,       // VSX Scalar Negative Multiply-Add Type A Double-Precision
   PPCOp_xsnmaddmdp,       // VSX Scalar Negative Multiply-Add Type M Double-Precision
   PPCOp_xsnmsubadp,       // VSX Scalar Negative Multiply-Subtract Type A Double-Precision
   PPCOp_xsnmsubmdp,       // VSX Scalar Negative Multiply-Subtract Type M Double-Precision
   PPCOp_xsrdpic,          // VSX Scalar Round to Double-Precision exact using Current rounding mode
   PPCOp_xsredp,           // VSX Scalar Reciprocal Estimate Double-Precision
   PPCOp_xsrsqrtedp,       // VSX Scalar Reciprocal Square Root Estimate Double-Precision
   PPCOp_xxlor,            // VSX Logical OR
   PPCOp_xxlnor,           // VSX Logical NOR
   PPCOp_xxsel,            // VSX Select (Operands usage are diffent than fsel)
   PPCOp_xxsldwi,          // VSX Shift Left Double by Word Immediate
   PPCOp_xxspltw,          // VSX Splat Word
   PPCOp_xxpermdi,         // VSX Permute Doubleword Immediate
   PPCOp_xssqrtdp,         // VSX Scalar Square Root Double-Precision
   PPCOp_xssubdp,          // VSX Scalar Subtract Double-Precision
   PPCOp_xscvsxddp,        // VSX Scalar Convert Signed Integer Doubleword to Double-Precision
   PPCOp_xscvdpsp,         // VSX Scalar Convert From Double-Precision to Single-Precision
   PPCOp_xvadddp,          // VSX Vector Add Double-Precision
   PPCOp_xvmindp,          // VSX Vector Min Double-Precision
   PPCOp_xvmaxdp,          // VSX Vector Max Double-Precision
   PPCOp_xvcmpeqdp,        // VSX Vector Compare Equal To Double-Precision
   PPCOp_xvcmpeqdp_r,      // VSX Vector Compare Equal To Double-Precision
   PPCOp_xvcmpgedp,        // VSX Vector Compare Greater Than Or Equal To Double-Precision
   PPCOp_xvcmpgedp_r,      // VSX Vector Compare Greater Than Or Equal To Double-Precision
   PPCOp_xvcmpgtdp,        // VSX Vector Compare Greater Than Double-Precision
   PPCOp_xvcmpgtdp_r,      // VSX Vector Compare Greater Than Double-Precision
   PPCOp_xvdivdp,          // VSX Vector Divide Double-Precision
   PPCOp_xvmuldp,          // VSX Vector Multiply Double-Precision
   PPCOp_xvnegdp,          // VSX Vector Negate Double-Precision
   PPCOp_xvnmsubadp,       // VSX Vector Negative Multiply-Subtract Type-A Double-Precision
   PPCOp_xvnmsubmdp,       // VSX Vector Negative Multiply-Subtract Type-M Double-Precision
   PPCOp_xvsubdp,          // VSX Vector Subtract Double-Precision
   PPCOp_xvmaddadp,        // VSX Vector Multiply-Add Type-A Double-Precision
   PPCOp_xvmaddmdp,        // VSX Vector Multiply-Add Type-M Double-Precision
   PPCOp_xvmsubadp,        // VSX Vector Multiply-Sub Type-A Double-Precision
   PPCOp_xvmsubmdp,        // VSX Vector Multiply-Sub Type-M Double-Precision
   PPCOp_xvsqrtdp,         // VSX Vector Square Root Double-Precision
   PPCOp_fmrgew,           // Merge Even Word
   PPCOp_fmrgow,           // Merge Odd Word
   PPCOp_lxsiwax,          // VSX Scalar as Integer Word Algebraic Indexed
   PPCOp_lxsiwzx,          // VSX Scalar as Integer Word and Zero Indexed
   PPCOp_lxsspx,           // VSX Scalar Single-Precision Indexed
   PPCOp_stxsiwx,          // VSX Scalar as Integer Word Indexed
   PPCOp_stxsspx,          // VSR Scalar Word Indexed
   PPCOp_xsaddsp,          // Scalar Add Single-Precision
   PPCOp_xscvdpspn,        // Scalar Convert Double-Precision to Single-Precision format Non-signalling
   PPCOp_xscvdpuxds,       // Scalar Convert Double-Precision to Unsigned Fixed-Point Doubleword Saturate
   PPCOp_xscvdpuxws,       // Scalar Convert Double-Precision to Unsigned Fixed-Point Word Saturate
   PPCOp_xscvspdp,         // Scalar Convert Single-Precision to Double-Precision (p=1)
   PPCOp_xscvspdpn,        // Convert Single-Precision to Double-Precision format Non-signalling
   PPCOp_xscvsxdsp,        // Scalar Convert Signed Fixed-Point Doubleword to Single-Precision
   PPCOp_xscvuxddp,        // Scalar Convert Unsigned Fixed-Point Doubleword to Double-Precision
   PPCOp_xscvuxdsp,        // Scalar Convert Unsigned Fixed-Point Doubleword to Single-Precision
   PPCOp_xsdivsp,          // Scalar Divide Single-Precision
   PPCOp_xsmaddasp,        // Scalar Multiply-Add Type-A Single-Precision
   PPCOp_xsmaddmsp,        // Scalar Multiply-Add Type-M Single-Precision
   PPCOp_xsmaxdp,          // Scalar Maximum Double-Precision
   PPCOp_xsmindp,          // Scalar Minimum Double-Precision
   PPCOp_xsmsubasp,        // Scalar Multiply-Subtract Type-A Single-Precision
   PPCOp_xsmsubmsp,        // Scalar Multiply-Subtract Type-M Single-Precision
   PPCOp_xsmulsp,          // Scalar Multiply Single-Precision
   PPCOp_xsnmaddasp,       // Scalar Negative Multiply-Add Type-A Single-Precision
   PPCOp_xsnmaddmsp,       // Scalar Negative Multiply-Add Type-M Single-Precision
   PPCOp_xsnmsubasp,       // Scalar Negative Multiply-Subtract Type-A Single-Precision
   PPCOp_xsnmsubmsp,       // Scalar Negative Multiply-Subtract Type-M Single-Precision
   PPCOp_xsrdpi,           // Scalar Round to Double-Precision Integer
   PPCOp_xsrdpim,          // Scalar Round to Double-Precision Integer toward -Infinity
   PPCOp_xsrdpip,          // Scalar Round to Double-Precision Integer toward +Infinity
   PPCOp_xsrdpiz,          // Scalar Round to Double-Precision Integer toward Zero
   PPCOp_xsresp,           // Scalar Reciprocal Estimate Single-Precision
   PPCOp_xsrsp,            // Scalar Round to Single-Precision
   PPCOp_xsrsqrtesp,       // Scalar Reciprocal Square Root Estimate Single-Precision
   PPCOp_xssqrtsp,         // Scalar Square Root Single-Precision
   PPCOp_xssubsp,          // Scalar Subtract Single-Precision
   PPCOp_xxland,           // Logical AND
   PPCOp_xxlandc,          // Logical AND with Complement
   PPCOp_xxleqv,           // Logical Equivalence
   PPCOp_xxlnand,          // Logical NAND
   PPCOp_xxlorc,           // Logical OR with Complement
   PPCOp_xxlxor,           // Logical XOR
   PPCOp_xxmrghw,          // Merge High Word
   PPCOp_xxmrglw,          // Merge Low Word
   PPCOp_vmrgew,           // Merge Even Word
   PPCOp_vmrgow,           // Merge Odd Word
   PPCOp_xvabsdp,          // Vector Absolute Value Double-Precision
   PPCOp_xvabssp,          // Vector Absolute Value Single-Precision
   PPCOp_xvaddsp,          // Vector Add Single-Precision
   PPCOp_xvcmpeqsp,        // Vector Compare Equal To Single-Precision
   PPCOp_xvcmpeqsp_r,      // Vector Compare Equal To Single-Precision & record CR6
   PPCOp_xvcmpgesp,        // Vector Compare Greater Than or Equal To Single-Precision
   PPCOp_xvcmpgesp_r,      // Vector Compare Greater Than or Equal To Single-Precision & record CR6
   PPCOp_xvcmpgtsp,        // Vector Compare Greater Than Single-Precision
   PPCOp_xvcmpgtsp_r,      // Vector Compare Greater Than Single-Precision & record CR6
   PPCOp_xvcpsgndp,        // Vector Copy Sign Double-Precision
   PPCOp_xvcpsgnsp,        // Vector Copy Sign Single-Precision
   PPCOp_xvcvdpsp,         // Vector Convert Double-Precision to Single-Precision
   PPCOp_xvcvdpsxds,       // Vector Convert Double-Precision to Signed Fixed-Point Doubleword Saturate
   PPCOp_xvcvdpsxws,       // Vector Convert Double-Precision to Signed Fixed-Point Word Saturate
   PPCOp_xvcvdpuxds,       // Vector Convert Double-Precision to Unsigned Fixed-Point Doubleword Saturate
   PPCOp_xvcvdpuxws,       // Vector Convert Double-Precision to Unsigned Fixed-Point Word Saturate
   PPCOp_xvcvspdp,         // Vector Convert Single-Precision to Double-Precision
   PPCOp_xvcvspsxds,       // Vector Convert Single-Precision to Signed Fixed-Point Doubleword Saturate
   PPCOp_xvcvspsxws,       // Vector Convert Single-Precision to Signed Fixed-Point Word Saturate
   PPCOp_xvcvspuxds,       // Vector Convert Single-Precision to Unsigned Fixed-Point Doubleword Saturate
   PPCOp_xvcvspuxws,       // Vector Convert Single-Precision to Unsigned Fixed-Point Word Saturate
   PPCOp_xvcvsxddp,        // Vector Convert Signed Fixed-Point Doubleword to Double-Precision
   PPCOp_xvcvsxdsp,        // Vector Convert Signed Fixed-Point Doubleword to Single-Precision
   PPCOp_xvcvsxwdp,        // Vector Convert Signed Fixed-Point Word to Double-Precision
   PPCOp_xvcvsxwsp,        // Vector Convert Signed Fixed-Point Word to Single-Precision
   PPCOp_xvcvuxddp,        // Vector Convert Unsigned Fixed-Point Doubleword to Double-Precision
   PPCOp_xvcvuxdsp,        // Vector Convert Unsigned Fixed-Point Doubleword to Single-Precision
   PPCOp_xvcvuxwdp,        // Vector Convert Unsigned Fixed-Point Word to Double-Precision
   PPCOp_xvcvuxwsp,        // Vector Convert Unsigned Fixed-Point Word to Single-Precision
   PPCOp_xvdivsp,          // Vector Divide Single-Precision
   PPCOp_xvmaddasp,        // Vector Multiply-Add Type-A Single-Precision
   PPCOp_xvmaddmsp,        // Vector Multiply-Add Type-M Single-Precision
   PPCOp_xvmaxsp,          // Vector Maximum Single-Precision
   PPCOp_xvminsp,          // Vector Minimum Single-Precision
   PPCOp_xvmsubasp,        // Vector Multiply-Subtract Type-A Single-Precision
   PPCOp_xvmsubmsp,        // Vector Multiply-Subtract Type-M Single-Precision
   PPCOp_xvmulsp,          // Vector Multiply Single-Precision
   PPCOp_xvnabsdp,         // Vector Negative Absolute Value Double-Precision
   PPCOp_xvnabssp,         // Vector Negative Absolute Value Single-Precision
   PPCOp_xvnegsp,          // Vector Negate Single-Precision
   PPCOp_xvnmaddadp,       // Vector Negative Multiply-Add Type-A Double-Precision
   PPCOp_xvnmaddasp,       // Vector Negative Multiply-Add Type-A Single-Precision
   PPCOp_xvnmaddmdp,       // Vector Negative Multiply-Add Type-M Double-Precision
   PPCOp_xvnmaddmsp,       // Vector Negative Multiply-Add Type-M Single-Precision
   PPCOp_xvnmsubasp,       // Vector Negative Multiply-Subtract Type-A Single-Precision
   PPCOp_xvnmsubmsp,       // Vector Negative Multiply-Subtract Type-M Single-Precision
   PPCOp_xvrdpi,           // Vector Round to Double-Precision Integer
   PPCOp_xvrdpic,          // Vector Round to Double-Precision Integer using Current rounding mode
   PPCOp_xvrdpim,          // Vector Round to Double-Precision Integer toward -Infinity
   PPCOp_xvrdpip,          // Vector Round to Double-Precision Integer toward +Infinity
   PPCOp_xvrdpiz,          // Vector Round to Double-Precision Integer toward Zero
   PPCOp_xvredp,           // Vector Reciprocal Estimate Double-Precision
   PPCOp_xvresp,           // Vector Reciprocal Estimate Single-Precision
   PPCOp_xvrspi,           // Vector Round to Single-Precision Integer
   PPCOp_xvrspic,          // Vector Round to Single-Precision Integer using Current rounding mode
   PPCOp_xvrspim,          // Vector Round to Single-Precision Integer toward -Infinity
   PPCOp_xvrspip,          // Vector Round to Single-Precision Integer toward +Infinity
   PPCOp_xvrspiz,          // Vector Round to Single-Precision Integer toward Zero
   PPCOp_xvrsqrtedp,       // Vector Reciprocal Square Root Estimate Double-Precision
   PPCOp_xvrsqrtesp,       // Vector Reciprocal Square Root Estimate Single-Precision
   PPCOp_xvsqrtsp,         // Vector Square Root Single-Precision
   PPCOp_xvsubsp,          // Vector Subtract Single-Precision
   PPCOp_label,				// Destination of a jump
   PPCLastOp = PPCOp_label,
   PPCNumOpCodes = PPCLastOp + 1
} TR_PPCOpCodes;
#include "codegen/PPCOps2.hpp"

#endif
